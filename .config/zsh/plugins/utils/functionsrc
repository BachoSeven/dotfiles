# vi: ft=zsh
## Functions
# Some of this was stolen, amongst others, from https://github.com/SmartFinn/dotfiles. Thanks!

# noice
_exists() { (( $+commands[$1] )) }
_run() {
	# run command if it exists
	local -a saved_cmd=("$@")

	case "$1" in
		sudo) shift 1 ;;
	esac

	if command -v "$1" >/dev/null; then
		echo "\e[1;32m =>\e[0m" "${saved_cmd[@]}" >&2
		"${saved_cmd[@]}"
	fi
}

## Arch
# Pacman
mirrors() {
            grep -v '^$\|^#' /etc/pacman.d/mirrorlist | awk '{print $3}' | awk -F '/' '{print $3}';
}
rip() {
	[ -z "$1" ] && num="50" || num="$1"
	expac --timefmt='%Y-%m-%d %T' '%l\t%n %v' | sort | tail -n $num
}
removeTotPkgsAfterInput() {
	expac --timefmt='%Y-%m-%d %T' '%l\t%n %v' | sort | tail -50 | grep -A $1 $2 | cut -d ' ' -f2 | awk '{print $2}' | xargs sudo pacman -Rsc --noconfirm
}
ownedbypkg() {
	pacman -Qlq $1 | grep -v '/$' | xargs -r du -h | sort -h
}
fp() {
printf "$(pacman --color always "${@:--Ss}" \
	| sed 'N;s/\n//' \
	| fzf -m --ansi --preview 'pacman -Si {1}' \
	| sed 's/ .*//')\n"
}
fzfpacinstall() {
	sudo pacman -S $(fp)
}
getdeps() {
	expac -l '\n' %E -S $@ | sort -u
}
cleanup() {
	packages=($(pacman -Qttdq))
	[ -n "$packages" ] && _run sudo pacman -Rns $(echo $packages)
	_run rmshit
}
# AUR [not amazing for non-standard packages...]
aurpublish() {
	PKG="$1"
	_run git clone ssh://aur@aur.archlinux.org/"$PKG".git; cp PKGBUILD $PKG; cd $PKG
	_run yay -S namcap && namcap PKGBUILD; yay -Rs namcap
	_run makepkg -s && makepkg --printsrcinfo > .SRCINFO; echo "*" > .gitignore
	_run git add -f PKGBUILD .SRCINFO && git commit -m "Initial AUR package commit" && git push
}
aurupdate() {
	PKG="$1"
	yay -S namcap && namcap PKGBUILD && yay -Rs namcap
	makepkg -fs && makepkg --printsrcinfo > .SRCINFO &&
	git commit -a
	git push
}

gc() {
	git clone $@ && cd $(basename "$1" .git)
}
pgc() {
	git clone git@github.com:BachoSeven/$1.git
}

src_update() {
	for dir in $dirs; do
		git -C "$dir" rev-parse --is-inside-work-tree >/dev/null 2>&1 || continue
		printf '%s: ' "$dir:t"
		[ "$(($(git -C "$dir" remote | wc -l) > 1))" = "1" ] && { git -C "$dir" fetch --all || printf '%s: Could not fetch upstream...\n' "$dir:t" }
		git -C "$dir" pull 2>/dev/null || echo "Unable to upgrade."
	done
}

# Updates
dirs=(
	~/.config/brave_plugins/startpage
	~/.config/mpv/scripts/mpvSockets
	~/.local/src/subs
	~/.local/src/dwm
	~/.local/src/dwmblocks
	~/.local/src/st
	~/slsk/programs/AP2_QMK/annepro-qmk
	~/slsk/programs/AP2_QMK/annepro2-shine
	~/slsk/programs/AP2_QMK/AnnePro2-Tools
)
up2date() {
	_run yay
	_run sudo pacnews
	_run nvim +PlugUpdate +quitall
	_run zsh_update_plugins
	_run src_update $dirs
}

extract() {
	for f in "$@"
	do
		if [ ! -f "$f" ]; then
			printf "extract: '%s' is not a file\n" "$f" >&2
			return 1
		fi

		case "$f" in
			*.tar)  tar -xf "$f"       ;;
			*.tar.bz|*.tbz| \
			*.tar.bz2|*.tbz2)
					tar -xjf "$f"      ;;
			*.tar.gz|*.tgz)
					tar -xzf "$f"      ;;
			*.tar.xz|*.txz)
					tar -xJf "$f"      ;;
			*.tar.[zZ]|*.t[zZ])
					tar -xZf "$f"      ;;
			*.tar.lz|*.tlz| \
			*.tar.lzma|*.tlzma| \
			*.tar.lzo|*.tzo| \
			*.tar.zst|*.tzst)
					tar -xaf "$f"      ;;
			*.7z)   7za x -- "$f"      ;;
			*.a|*.ar)
					ar x -- "$f"       ;;
			*.ace)  unace e -- "$f"    ;;
			*.alz)  unalz -- "$f"      ;;
			*.arc|*.ark|*.ARC|*.ARK)
					nomarch -- "$f"    ;;
			*.arj|*.ARJ)
					arj e -r -- "$f"   ;;
			*.bz|*.bz2)
					bunzip2 -k -- "$f" ;;
			*.cab|*.CAB|*.exe|*.EXE)
					cabextract "$f"    ;;
			*.cpio) cpio -id -F "$f"   ;;
			*.deb)  dpkg -x -- "$f" .  ;;
			*.gz)   gunzip -k "$f"     ;;
			*.lha|*.lzh)
					lha x "$f"         ;;
			*.lrz|*.lrzip|*.rz)
					lrunzip -- "$f"    ;;
			*.lz)   lzip -d -k -- "$f" ;;
			*.lz4)  unlz4 -- "$f"      ;;
			*.lzma) xz -d -k "$f"      ;;
			*.lzo)  lzop -x "$f"       ;;
			*.rar)  unrar x -- "$f"    ;;
			*.src.rpm|*.rpm|*.spm)
					rpm2cpio "$f" | cpio -dium ;;
			*.xz)   unxz -k -- "$f"    ;;
			*.[zZ]) uncompress -- "$f" ;;
			*.zip)  unzip -- "$f"      ;;
			*.zst)  unzstd -- "$f"     ;;
			*.AppImage) ./"$f" --appimage-extract ;;
			*)
				printf "extract: '%s' - unkwown archive format\n" "$f" >&2
				return 1
		esac
	done
}

archive() {
	if [ "$#" -lt 2 ]; then
		printf "usage: $0 <ARCHIVE> [FILE...]\n" >&2
		return 1
	fi

	local archive="$1"; shift

	case "$archive" in
		*.tar.bz|*.tbz| \
		*.tar.bz2|*.tbz2)
			tar -cjf "$archive" "$@" ;;
		*.tar.gz|*.tgz)
			tar -czf "$archive" "$@" ;;
		*.tar.xz|*.txz)
			tar -cJf "$archive" "$@" ;;
		*.tar.[zZ]|*.t[zZ])
			tar -cZf "$archive" "$@" ;;
		*.tar.lzma|*.tlzma| \
		*.tar.lzo|*.tzo| \
		*.tar.lz|*.tlz)
			tar -caf "$archive" "$@" ;;
		*.tar)
			tar -cf  "$archive" "$@" ;;
		*.7z)
			7za a    "$archive" "$@" ;;
		*.zip)
			zip -r   "$archive" "$@" ;;
		*)
			printf "'%s' is unknown archive format\n" "$archive" >&2
			return 1
	esac
}

sfont() {
	fc-list		|
	cut -f2 -d:	|
	grep -i "$1"
}

vinfo() {
	nvim -c "Vinfo $@" -c 'silent only' # See https://github.com/alx741/vinfo
}

## DICTIONARY FUNCTIONS ##
djargon () { curl dict://dict.org/d:${1}:jargon; }
dfoldoc () { curl dict://dict.org/d:${1}:foldoc; }
dthesaurus () { curl dict://dict.org/d:${1}:moby-thes; }
# Dictionary | Usage define <foo>
define() {
    curl -s dict://dict.org/d:$1 | grep -v '^[0-9]'
}
## Stardict
### Sdcv
def() {
	sdcv -n --utf8-output --color "$@" 2>&1 | \
	fold --width=$(tput cols) | \
	less -FRX
}
ita() {
	sdcv -n --data-dir "$XDG_DATA_HOME/stardict/ita" -u "vocabolario" --utf8-output --color "$@" 2>&1 | \
	fold --width=$(tput cols) | \
	less -FRX
}
the() {
	sdcv -n -u "English Thesaurus" --utf8-output --color "$@" 2>&1 | \
	fold --width=$(tput cols) | \
	less -FRX
}

ety() {
	sdcv -n -u "English Etymology" --utf8-output --color "$@" 2>&1 | \
	fold --width=$(tput cols) | \
	less -FRX
}
turkeng() {
	sdcv -n --data-dir "$XDG_DATA_HOME/stardict/turk" -u "Babylon Turkish-English" --utf8-output --color "$@" 2>&1 | \
	fold --width=$(tput cols) | \
	less -FRX
}
engturk() {
	sdcv -n --data-dir "$XDG_DATA_HOME/stardict/turk" -u "Babylon English-Turkish" --utf8-output --color "$@" 2>&1 | \
	fold --width=$(tput cols) | \
	less -FRX
}

# ListProcesses - Update the list of processes by pressing CTRL-R
lps() {
ps -ef | fzf --bind 'ctrl-r:reload(ps -ef)' --header 'Press CTRL-R to reload' \
	 --header-lines=1 --layout=reverse
}

chromiumhist() {
	# https://junegunn.kr/2015/04/browsing-chrome-history-with-fzf/
	# https://github.com/junegunn/fzf/wiki/examples#browsing-history
	local cols sep temp_hist

	cols=$(( COLUMNS / 3 ))
	sep='{::}'
	temp_hist="$(mktemp -u)"

	command cp -f "$HOME"/.config/chromium/Default/History "$temp_hist"

	sqlite3 -separator "$sep" "$temp_hist" \
		"select substr(title, 1, $cols), url from urls order by last_visit_time desc" |
			awk -F "$sep" '{printf "%-'$cols's  \x1b[36m%s\x1b[m\n", $1, $2}' |
			fzf --ansi --multi | sed 's#.*\(https*://\)#\1#' | xargs -r $BROWSER

	rm -f "$temp_hist"
}

wtr() {
	# see curl wttr.in/:help
	local loc="${1:=$LOCATION}"
	local opts="${2:=pqtF&lang=it}"

	curl wttr.in/${loc}\?${opts} 2>/dev/null | less -RE
}
wtrg() {
	# see curl wttr.in/:help
	local loc="${1:=$LOCATION}"
	local opts="${2:=pqtF&lang=it}"

	curl v2.wttr.in/${loc}\?${opts} 2>/dev/null | less -RE
}

most-used-commands() {
	local -i top="${1:-10}"
	local -i last="${2:-999999}"

	tail -n "$last" "${HISTFILE:-${ZDOTDIR:-$HOME}/.zsh_history}" \
		| awk '
			{ $1 == "sudo" ? CMD[$2]++ : CMD[$1]++; count++; }
			END {
				for (a in CMD)
					print CMD[a] " " CMD[a]/count*100 "% " a;
				}' \
		| sort -nr \
		| head -n "$top" \
		| column -c2 -s " " -t \
		| nl
}

# xdg-open wrapper
open() {
	for f in $@; do
		setsid -f $OPENER $f >/dev/null 2>&1
	done
}

logzsh() { # Fix
	zsh -xv 2>&1 | ts -i "%.s" > zshstartup.log
	sort --field-separator=' ' -r -k1 zshstartup.log > sorted.log
}

zsh_bench() {
	for _ ({1..10}); time zsh -i -c exit
}

## Colors
function 256col {
	for i in {0..255}; do print -Pn "%K{$i}  %k%F{$i}${(l:3::0:)i}%f " ${${(M)$((i%6)):#3}:+$'\n'}; done
}
xrescol() {
	read -r -d '' -A colors \
	    < <( xrdb -query | sed -n 's/.*color\([0-9]\)/\1/p' | sort -nu | cut -f2)
	printf '\e[1;37m\n Black      Red        Green      Yellow     Blue       Magenta    Cyan       White\n───────────────────────────────────────────────────────────────────────────────────────\e[0m\n'
	for color in {0..7}; do printf "\e[$((30+color))m █ %s \e[0m" "${colors[color+1]}"; done
	printf '\n'
	for color in {8..15}; do printf "\e[1;$((22+color))m █ %s \e[0m" "${colors[color+1]}"; done
	printf '\n'
}
truecolor() {
	awk 'BEGIN{
	    s="/\\/\\/\\/\\/\\"; s=s s s s s s s s;
	    for (colnum = 0; colnum<77; colnum++) {
		r = 255-(colnum*255/76);
		g = (colnum*510/76);
		b = (colnum*255/76);
		if (g>255) g = 510-g;
		printf "\033[48;2;%d;%d;%dm", r,g,b;
		printf "\033[38;2;%d;%d;%dm", 255-r,255-g,255-b;
		printf "%s\033[0m", substr(s,colnum+1,1);
	    }
	    printf "\n";
	}'
}
## Fill screen with colours | Usage: colours
colours()
{
  _I=1
  _J=0
  _K=0
  _WIDTH=$COLUMNS
  _MARGIN=0
  while true; do
  _A=$(($RANDOM % 3))
  _B=$(($RANDOM % 2))
  _C=$(($RANDOM % 3))
  case $_A in
  0)
    case $_B in
    0)
      [ $_I -gt 1 ] && _I=$(($_I - 1))
    ;;
    1)
      [ $_I -lt 6 ] && _I=$(($_I + 1))
    ;;
    esac
  ;;
  1)
    case $_B in
    0)
      [ $_J -gt 0 ] && _J=$(($_J - 1))
    ;;
    1)
      [ $_J -lt 5 ] && _J=$(($_J + 1))
    ;;
    esac
  ;;
  2)
    case $_B in
    0)
      [ $_K -gt 0 ] && _K=$(($_K - 1))
    ;;
    1)
      [ $_K -lt 5 ] && _K=$(($_K + 1))
    ;;
    esac
  ;;
  esac
  case $1 in
    1)
      _DELTA=$2
      case $_C in
        0)
          [ $_WIDTH -lt $(($COLUMNS - 2*$_DELTA)) ] && _WIDTH=$(($_WIDTH + 2*$_DELTA))
        ;;
        1)
          [ $_WIDTH -gt $((1 + 2*$_DELTA)) ] && _WIDTH=$(($_WIDTH - 2*$_DELTA))
        ;;
      esac
      _MARGIN=$((($COLUMNS-$_WIDTH)/2))
    ;;
    2)
      _WIDTH=$2
      _DELTA=$3
      case $_C in
        0)
          [ $_MARGIN -le $(($COLUMNS - $_WIDTH - $_DELTA)) ] && _MARGIN=$(($_MARGIN + $_DELTA))
        ;;
        1)
          [ $_MARGIN -ge $_DELTA ] && _MARGIN=$(($_MARGIN - $_DELTA))
        ;;
      esac
    ;;
    *)
      _WIDTH=$COLUMNS
      _MARGIN=0
    ;;
  esac
  _NUMBER=$((15 + $_I + 6*$_J + 36*$_K))

  printf "\e[0;49m"
  if [ $_MARGIN -gt 0 ]; then
    for _FOO in $(seq $_MARGIN); do
      printf " "
    done
  fi

  printf "\e[0;48;5;${_NUMBER}m"
  for _FOO in $(seq $_WIDTH); do
    printf " "
  done

  printf "\e[0;49m\n"
  done
}

# a simple password generator
genpasswd() {
	# usage: genpasswd [-adhps] [length [count]]
	local -i human_readable=0
	local chars=""

	while getopts "adhps" opt; do
		case "$opt" in
			a) chars+="[:alnum:]" ;;
			d) chars+="[:digit:]" ;;
			p) chars+="[:punct:]" ;;
			s) chars+="[:graph:]" ;;
			h) human_readable=1   ;;
		esac
	done
	shift $((OPTIND - 1))

	local -i length="${1:-8}"
	local -i count="${2:-1}"

	if [ "$human_readable" -eq 1 ]; then
		command -v apg >/dev/null || return 1
		apg -c /dev/urandom -m "$length" -n "$count" -E oOlL10
	else
		< /dev/urandom \
			| tr -dc "${chars:-[:alnum:]}" \
			| fold -w "$length" \
			| head -n "$count"
	fi
}

## Audio
# Calculate average bitrate of files in current folder
avekbps() {
	[ -z $"1" ] && printf "No format specified... (i.e. `avepbps mp3`)"
	format=$1
	mediainfo --Output=JSON *.$format | grep '"BitRate":' | cut -d: -f2 | sed "s/\"//g;s/,//g;s/ //g" | awk '{ total += $1 } END { print total/(1000*NR) }'
}
awkcompose() {
[ "$#" -lt 1 ] && printf "Usage: awkcompose OUTPUT_NAME [SAMPLE_RATE:-48000]\n" && return 1
output="awk_$1"
rate=${2:-48000}
awk -v rate="$rate" 'function wl() {
        return (rate/160)*(0.87055^(int(rand()*10)))};
    BEGIN {
        srand();
        wla=wl();
        while(1) {
            wlb=wla;
            wla=wl();
            if (wla==wlb)
                {wla*=2;};
            d=(rand()*10+5)*rate/4;
            a=b=0; c=128;
            ca=40/wla; cb=20/wlb;
            de=rate/10; di=0;
            for (i=0;i<d;i++) {
                a++; b++; di++; c+=ca+cb;
                if (a>wla)
                    {a=0; ca*=-1};
                if (b>wlb)
                    {b=0; cb*=-1};
                if (di>de)
                    {di=0; ca*=0.9; cb*=0.9};
                printf("%c",c)};
            c=int(c);
            while(c!=128) {
                c<128?c++:c--;
                printf("%c",c)};};}' > $output.raw
}
8bit_raw2flac(){
	[ "$#" -lt 2 ] && printf "Usage: 8bit_raw2flac INPUT.raw OUTPUT.flac [SAMPLE_RATE:-384000]\n" && return 1
	input=$1; output=$2; rate=${3:-384000}
	sox -r $rate -e unsigned -b 8 -c 1 $input $output
}
flac2mp3(){
    for infile in "$@"; do
        [[ "${infile}" != *.flac ]] && continue
        album="$(metaflac --show-tag=album "${infile}" | sed 's/[^=]*=//')"
        artist="$(metaflac --show-tag=artist "${infile}" | sed 's/[^=]*=//')"
        date="$(metaflac --show-tag=date "${infile}" | sed 's/[^=]*=//')"
        title="$(metaflac --show-tag=title "${infile}" | sed 's/[^=]*=//')"
        year="$(metaflac --show-tag=date "${infile}" | sed 's/[^=]*=//')"
        genre="$(metaflac --show-tag=genre "${infile}" | sed 's/[^=]*=//')"
        tracknumber="$(metaflac --show-tag=tracknumber "${infile}" | sed 's/[^=]*=//')"

        flac --decode --stdout "${infile}" | lame -b 320 --add-id3v2 \
            --tt "${title}" \
            --ta "${artist}" \
            --tl "${album}" \
            --ty "${year}" \
            --tn "${tracknumber}" \
            --tg "${genre}" - "${infile%.flac}.mp3"
    done
}

## ffmpeg utilities
compressvid() {
	ffmpeg -i $1 -vcodec h264 -acodec mp3 $2
}
compressvidbrate() {
	bitrate=${3:-1000k}
	ffmpeg -i $1 -vcodec h264 -b:v $bitrate -acodec mp3 $2
}
fixallmkv() {
	for file in *.mkv; do ffmpeg -i $file -c copy "${file%.*}-fixed.${file##*.}"; done
}

genplaylist() {
	[ -z $1 ] && name="playlist" || name=$1
	[ -z $2 ] && ext="mp3" || ext=$2
	playlist="${name}.m3u" ; if [ -f $playlist ]; then rm -i $playlist ; fi ; for f in *.$ext; do echo "$(pwd)/$f" >> "$playlist"; done
}

# create a new directory and enter it
md() {
	mkdir -p $@ && cd ${@:$#}
}

# fuzzy-find manuals
manfd() {
    export MANPATH="/usr/share/man"
    f=$(fd . $MANPATH/man${1:-1} -t f -x echo {/.} | fzf --preview 'man {}'  ) && man $f
}

# find inside manuals
fman() {
    man -k . | fzf --prompt='Man> ' | awk '{print $1}' | xargs -r man
}

# simple gpg encryption
encrypt() {
	gpg --output $1.gpg --symmetric --cipher-algo AES256 $1
}

# Shellcheck all of my scripts
scck() {
	scripts=(
		/home/fra/.local/bin/statusbar
		/home/fra/.local/bin/scripts
		/home/fra/.local/bin/cron
		/home/fra/.local/bin/colors
	)
	for dir in $scripts; do
		while read script; do
			shellcheck -x $dir/$script
		done <<< $(\ls --format single-column $dir)
	done
}

# amazing
stopwatch(){
    date1=`date +%s`;
    while true; do
        days=$(( $(($(date +%s) - date1)) / 86400 ))
        printf "$days day(s) and $(date -u --date @$((`date +%s` - $date1)) +%H:%M:%S)\r";
        sleep 0.1
    done
}

## Imagemagick
75%() { mogrify -resize '75%X75%' "$@" ; }
50%() { mogrify -resize '50%X50%' "$@" ; }
25%() { mogrify -resize '25%X25%' "$@" ; }
## pdf utils
img2pdf() {
	while read file; do
	filebase=$(basename $file | cut -d'.' -f1)
	convert -density 300 -quality 100 $file $filebase.pdf
	done <<< $(ls)
}
pdfsearch() {
	command -v pdftotext >/dev/null && mkdir -p tmpd; ls *.pdf |
		while read file; do
			pdftotext $file tmpd/$file.txt;
		done
		rg $1 tmpd && rm -rf tmpd || echo 'Error!'
}
compresspdf() {
	gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/screen -dNOPAUSE -dBATCH  -dQUIET -sOutputFile=$2.pdf $1
	## screen << ebook << prepress
	# ps2pdf LARGE.pdf SMALL.pdf
}

## Web Stuff
# URL Shortener  | Usage : short <url>
short() {
  curl -F"shorten=$*" https://0x0.st
}

# Upload-file | Usage : share /path/to/file.foo (256 Mib limit)
share() {
  curl -F"file=@$*" https://0x0.st
}
# Readable
readw3m() {
	readable -q $@ |
	w3m -config $XDG_CONFIG_HOME/w3m/config -T text/html -graph
}
readlynx() {
	readable -q $@ |
	lynx -assume_charset="UTF-8" -display_charset=utf-8 -editor=nvim -vikeys -stdin -force_html -nomargins -notitle -prettysrc
}
# A wget wrapper
download_files_from_page() {
	if [ "$#" -lt 2 ]; then
		cat <<- EOF
		Download all files with specific extension on a webpage
		Usage: $0 extension[,extension...] URL
		Example:
		$0 mp4 http://example.com/files/
		$0 mp3,ogg,wma http://samples.com/files/
		Google: http://lmgtfy.com/?q=intitle%3Aindex.of+mp3+-html+-htm+-php+-asp+-txt+-pls+madonna
		based on http://stackoverflow.com/a/18709707
		EOF

		return 1
	fi

	outputdir_name="$(awk -F/ '{print $(NF-1);}' <<< "$1")"
	mkdir -pv "$outputdir_name"
	cd "$outputdir_name"
	wget -c -r -l1 -H -t1 -nd -N -np -A "$1" -erobots=off "$2" || ( cd .. && rm -ir "$outputdir_name" )
}

# Efficient way to select a line to print to stdout: https://unix.stackexchange.com/questions/29878/can-i-access-nth-line-number-of-standard-output
line() {
	awk "NR==$1{print;exit}"
}

confirm() {
    local answer
    printf "zsh: sure you want to run '${YELLOW}$*${NC}' [yN]? "
    read -q answer
        echo
    if [[ "${answer}" =~ ^[Yy]$ ]]; then
        command "${@}"
    else
        return 1
    fi
}

confirm_wrapper() {
    if [ "$1" = '--root' ]; then
        local as_root='true'
        shift
    fi

    local prefix=''

    if [ "${as_root}" = 'true' ] && [ "${USER}" != 'root' ]; then
        prefix="sudo"
    fi
    confirm ${prefix} "$@"
}

# stolen with the above from https://github.com/slashbeast/conf-mgmt/blob/master/roles/home_files/files/DOTzshrc
poweroff() { confirm_wrapper --root $0 "$@"; }
reboot() { confirm_wrapper --root $0 "$@"; }
hibernate() { confirm_wrapper --root $0 "$@"; }
